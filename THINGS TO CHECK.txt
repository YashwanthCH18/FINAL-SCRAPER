Appendix A – Shared Infrastructure & Auth Foundations
(Why every stack must include them)

This section explains in depth the two cross-cutting building blocks that bind all micro-services together:

The Routing / API-Gateway layer created by AWS SAM
The Tenant-ID & Auth middleware executed inside each service
Understanding these will clarify why they appear in the Blog, Scraper, LinkedIn and future Video stacks alike.

1 Routing / API-Gateway Layer (declared in template.yaml)
What it is
• An AWS::Serverless::HttpApi resource generated by SAM.
• Provides one HTTPS entry-point (e.g. https://api.myname.com) for the entire application.
• Handles TLS, CORS, throttling, structured logging to CloudWatch, and—most importantly—JWT authentication before the request ever reaches a Lambda.

How it works
JWT Authorizer block inside the API definition points to Supabase’s JWKS endpoint.
For every Lambda you add an HttpApi event.
Path: /blog/{proxy+}      → BlogFunction
Path: /scraper/{proxy+}   → ScraperFunction
Path: /linkedin/{proxy+}  → LinkedInFunction
The gateway matches the incoming path, validates the JWT, and forwards the request to the correct Lambda along with:
• event.requestContext.authorizer.jwt.claims – the decoded token
• x-amzn-trace-id, x-request-id – tracing headers
Why every stack needs it
• Single custom domain – FE code stays simple.
• Centralised auth – a bug in one service cannot skip JWT verification.
• Uniform rate limits – prevents one stack from DoS-ing another.
• Simpler deployments – you edit only template.yaml; SAM provisions & wires everything automatically.

Without it you would have to:
• expose four separate Lambda URLs,
• repeat JWT validation logic in each,
• configure per-function throttling manually.

2 Tenant-ID & Auth Middleware (imported by each FastAPI app)
What it is
A tiny shared Python module, e.g. common_auth.py:

python
from fastapi import Request, HTTPException, Header

async def get_user_id(request: Request) -> str:
    claims = request.scope["aws.context"]["authorizer"]["jwt"]["claims"]
    user_id = claims.get("sub")           # Supabase stores UID in `sub`
    if not user_id:
        raise HTTPException(status_code=401)
    return user_id
Each endpoint declares:

python
from fastapi import Depends
@app.post("/auto-generate")
async def auto_generate(data: BlogRequest,
                        user_id: str = Depends(get_user_id)):
    ...
What it does
• Extracts the already-validated tenant identifier (user_id) from the request.
• Makes that value available to business logic, ORMs, Pinecone client, Supabase Storage client, etc.

Why every stack needs it
Concern	Role of the middleware
Row-Level Security	Adds WHERE user_id = :uid automatically via the ORM.
Vector isolation	Passes namespace=user_id to Pinecone.
Storage prefixing	Saves files under blog_media/<user_id>/….
Async-job ownership	Writes jobs.user_id so workers pick up only matching rows.
Audit & trace	Emits log.info(f"{user_id} called /blog/auto-generate").
Because Lambdas are stateless, every invocation must reload the tenant context from the request; importing this module in all four services guarantees consistent behaviour.

What happens if you omit it in one stack?
• That service could accidentally read or write another tenant’s data.
• RLS might still block reads, but writes (e.g. to Pinecone or Storage) could mix data.
• Debug logs would lack tenant IDs, complicating incident analysis.

Relationship between the two blocks
API-Gateway (Infrastructure) – verifies the JWT once and injects claims.
Middleware (Application code) – consumes those claims inside each stack.
They are complementary; one without the other is either insecure (skip gateway) or non-functional (skip middleware).

Implementation Checklist (per stack)
Task	Where	Done once?
Add Path: /stack/{proxy+} route	template.yaml	Yes
Reference SupabaseAuth authorizer	template.yaml	Yes
pip install common_auth or include module	code repo	Yes
Add Depends(get_user_id) to every FastAPI router	code	Per endpoint
Follow this checklist for Blog, Scraper, LinkedIn, and future Video stacks to ensure identical, reliable multi-tenant behaviour across the entire SaaS platform.










i also noticed a problem while i had deployed something else in the past i will tell it to u so that u dont make the same mistake, here is the mistake and solution dont do the same mistake 

What was happening: the frontend could connect, but the server responded that it couldn't find the /auth/signup or /auth/login endpoints.
The Root Cause: There was a mismatch between the URL paths defined in your AWS API Gateway and the paths your Express app was expecting.
Your API Gateway was configured to handle the /api part of the URL. When a request came in to .../api/auth/signup, the gateway would process the /api part and only forward /auth/signup to your Lambda function.
However, your 
server.js
 was still expecting the full path: app.use('/api/auth', ...). Since it only received /auth/signup, it couldn't find a match.
The Solution:
We updated the routes in 
src/server.js
 to match what the Lambda function actually receives from API Gateway. We removed the /api prefix from the app.use() calls.
app.use('/api/auth', ...) became app.use('/auth', ...).
app.use('/api', ...) became app.use('/', ...).
How to Avoid It in the Future:
Rule: When using API Gateway with a proxy integration, remember that the gateway's base path is stripped before the request reaches your code. Your application's internal routing must start from the path after the gateway's base path